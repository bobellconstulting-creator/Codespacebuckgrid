'use client'

import { useCallback, useEffect, useMemo, useRef } from 'react'
import type { Tool } from '../constants/tools'
import type * as LeafletNS from 'leaflet'

type LatLngLike = { lat: number; lng: number }

export type MapApi = {
  lockBoundary: () => number | null
  wipeAll: () => void
  getCaptureElement: () => HTMLElement | null
  getGeoJSON: () => any
}

function calculateAreaAcres(pts: LatLngLike[]) {
  if (pts.length < 3) return 0
  const radius = 6378137
  let area = 0
  for (let i = 0; i < pts.length; i++) {
    const p1 = pts[i]
    const p2 = pts[(i + 1) % pts.length]
    area += (p2.lng - p1.lng) * (Math.PI / 180) * (2 + Math.sin(p1.lat * (Math.PI / 180)) + Math.sin(p2.lat * (Math.PI / 180)))
  }
  return Number((Math.abs((area * radius * radius) / 2.0) * 0.000247105).toFixed(2))
}

export function useMapDrawing(args: { containerRef: React.RefObject<HTMLDivElement>, activeTool: Tool, brushSize: number, isDrawMode: boolean }) {
  const { containerRef, activeTool, brushSize, isDrawMode } = args
  const LRef = useRef<typeof LeafletNS | null>(null)
  const mapRef = useRef<LeafletNS.Map | null>(null)
  const drawnItemsRef = useRef<LeafletNS.FeatureGroup | null>(null)
  const boundaryLayerRef = useRef<LeafletNS.FeatureGroup | null>(null)
  const boundaryPointsRef = useRef<LatLngLike[]>([])
  const tempPathRef = useRef<LeafletNS.Polyline | null>(null)
  const isDrawingRef = useRef(false)
  const layerMetadataRef = useRef<Map<number, { acres: number, toolName: string }>>(new Map())

  const activeToolRef = useRef(activeTool)
  const brushSizeRef = useRef(brushSize)
  const isDrawModeRef = useRef(isDrawMode)
  useEffect(() => { activeToolRef.current = activeTool }, [activeTool])
  useEffect(() => { brushSizeRef.current = brushSize }, [brushSize])
  useEffect(() => { isDrawModeRef.current = isDrawMode }, [isDrawMode])

  useEffect(() => {
    let mounted = true
    const init = async () => {
      const leaflet = await import('leaflet')
      if (!mounted || !containerRef.current) return
      LRef.current = leaflet
      const map = leaflet.map(containerRef.current, { 
        center: [38.6583, -96.4937], 
        zoom: 16, 
        zoomControl: false, 
        attributionControl: false,
        dragging: true,
        scrollWheelZoom: true
      })
      leaflet.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, crossOrigin: true }).addTo(map)
      drawnItemsRef.current = new leaflet.FeatureGroup().addTo(map)
      boundaryLayerRef.current = new leaflet.FeatureGroup().addTo(map)
      mapRef.current = map
    }
    init()
    return () => { mounted = false }
  }, [containerRef])

  // Update map dragging based on draw mode
  useEffect(() => {
    if (!mapRef.current) return
    if (isDrawMode) {
      mapRef.current.dragging.disable()
      mapRef.current.scrollWheelZoom.disable()
    } else {
      mapRef.current.dragging.enable()
      mapRef.current.scrollWheelZoom.enable()
    }
  }, [isDrawMode])

  const onPointerDown = useCallback((e: React.PointerEvent) => {
    const L = LRef.current
    if (!mapRef.current || !L) return
    
    // Only allow drawing when in draw mode
    if (!isDrawModeRef.current) return
    
    const rect = containerRef.current!.getBoundingClientRect()
    const latlng = mapRef.current.containerPointToLatLng([e.clientX - rect.left, e.clientY - rect.top])
    if (activeToolRef.current.id === 'boundary') {
      boundaryPointsRef.current.push({ lat: latlng.lat, lng: latlng.lng })
      L.circleMarker(latlng, { color: '#FF6B00', radius: 5, fillOpacity: 1 }).addTo(boundaryLayerRef.current!)
      if (boundaryPointsRef.current.length > 1) L.polyline(boundaryPointsRef.current as any, { color: '#FF6B00', weight: 4 }).addTo(boundaryLayerRef.current!)
      return
    }
    isDrawingRef.current = true
    tempPathRef.current = L.polyline([latlng], { color: activeToolRef.current.color, weight: brushSizeRef.current, opacity: 0.6 }).addTo(drawnItemsRef.current!)
  }, [containerRef])

  const onPointerMove = useCallback((e: React.PointerEvent) => {
    if (!isDrawingRef.current || !tempPathRef.current) return
    const rect = containerRef.current!.getBoundingClientRect()
    tempPathRef.current.addLatLng(mapRef.current!.containerPointToLatLng([e.clientX - rect.left, e.clientY - rect.top]))
  }, [containerRef])

  const onPointerUp = useCallback(() => {
    if (!isDrawingRef.current || !tempPathRef.current) {
      isDrawingRef.current = false
      tempPathRef.current = null
      return
    }
    
    // Calculate acres for the drawn path
    const L = LRef.current
    if (L && tempPathRef.current) {
      const latlngs = (tempPathRef.current as any).getLatLngs() as LatLngLike[]
      if (latlngs.length > 2) {
        const acres = calculateAreaAcres(latlngs)
        const layerId = L.Util.stamp(tempPathRef.current)
        layerMetadataRef.current.set(layerId, {
          acres,
          toolName: activeToolRef.current.name
        })
        
        // Add a popup to show acreage
        tempPathRef.current.bindPopup(`${activeToolRef.current.name}: ${acres} acres`)
      }
    }
    
    isDrawingRef.current = false
    tempPathRef.current = null
  }, [])

  return { 
    api: { 
      lockBoundary: () => {
        const acres = calculateAreaAcres(boundaryPointsRef.current)
        if (!acres) return null
        boundaryLayerRef.current?.clearLayers()
        LRef.current!.polygon(boundaryPointsRef.current as any, { color: '#FF6B00', weight: 5, fillOpacity: 0.15 }).addTo(boundaryLayerRef.current!)
        return acres
      },
      wipeAll: () => {
        drawnItemsRef.current?.clearLayers()
        boundaryLayerRef.current?.clearLayers()
        boundaryPointsRef.current = []
        layerMetadataRef.current.clear()
      },
      getCaptureElement: () => containerRef.current,
      getGeoJSON: () => {
        const layers: any[] = []
        
        // Add boundary layer
        if (boundaryPointsRef.current.length > 0) {
          layers.push({
            type: 'Feature',
            properties: { type: 'boundary', acres: calculateAreaAcres(boundaryPointsRef.current) },
            geometry: {
              type: 'Polygon',
              coordinates: [boundaryPointsRef.current.map(p => [p.lng, p.lat])]
            }
          })
        }
        
        // Add drawn items with acreage
        drawnItemsRef.current?.eachLayer((layer: any) => {
          if (layer.toGeoJSON) {
            const geoJSON = layer.toGeoJSON()
            const layerId = LRef.current!.Util.stamp(layer)
            const metadata = layerMetadataRef.current.get(layerId)
            geoJSON.properties = { 
              color: layer.options?.color || '#fff',
              weight: layer.options?.weight || 1,
              acres: metadata?.acres || 0,
              toolName: metadata?.toolName || 'unknown'
            }
            layers.push(geoJSON)
          }
        })
        
        return {
          type: 'FeatureCollection',
          features: layers
        }
      }
    }, 
    handlers: { onPointerDown, onPointerMove, onPointerUp } 
  }
}
